---
title: "Financial Analytics - Trabalho Final"
authors:
  - name: Michel Maurice Conjaud
  - name: Hélio Pereira Oliveira
  - name: Renan Cabral
  - name: Tiago Evangelista Pardo
format:
  html:
    code-fold: true
    embed-resources: true
    smooth-scroll: true
    theme: cerulean
    toc: true
    toc-expand: true
    toc-title: "Sumário"
    toc_float: true

execute:
  freeze: true
  warning: false
  cache: true
---

# 0. Bibliotecas e Importação de Dados

Bibliotecas
```{r}
#| output: false
library(ggplot2)
library(fpp3)
library(rugarch)
library(tsibble)
library(yfR)
library(zoo)
library(xts)
library(lubridate)
library(patchwork)
library(lmtest)
library(fGarch)
library(xts)
library(FinTS)
library(tidyquant)
```


Seleção das Ações/Ativos e definição da data de início: 01/01/2019
```{r}
#| output: false

data_inicio <- '2019-01-01'

ativos <- c(
  "NVDC34.SA",
  "BCSA34.SA", 
  "AMZO34.SA",
  "RENT3.SA",
  "PRIO3.SA",
  "TASA4.SA"
)


# Importando base da API do Yahoo

da <- yfR::yf_get(
  ativos,
  first_date = data_inicio,
  last_date = Sys.Date(),
  bench_ticker = "^BVSP",
  type_return = "log",
  freq_data = "daily",
  do_complete_data = TRUE
)
view(da)

```

Data mínima comum a todas as séries

```{r}
# Capturando menor data da base 
data_corte <- da |>
  dplyr::group_by(ticker) |>
  dplyr::filter(ref_date == min(ref_date)) |>
  dplyr::ungroup() |>
  with(max(ref_date))

data_corte
```

```{r}
# Df com data mínima
da_train <- da |>
  dplyr::filter(ref_date > data_corte) 


# Capturando menor data da base 
data_corte <- da |>
  dplyr::group_by(ticker) |>
  dplyr::filter(ref_date == min(ref_date)) |>
  dplyr::ungroup() |>
  with(max(ref_date))



# Filtrando base com data mínima
da_train <- da |>
  dplyr::filter(ref_date > data_corte) 

# Transformando em Tsibble
da_tsibble <- da_train |>
  as_tsibble(key = ticker, index = ref_date, regular = FALSE)
```



# 1. Gráficos de Preço, Retorno e Avaliação de Heterodasticidade Condicional

## 1.1. Gráfico de preços


```{r}

#Função para formatar legenda
quarter_label <- function(x) {
  paste0(year(x), "Q", quarter(x))
}  
```

```{r}
#| fig-width: 7
#| fig-height: 10

#criando gráfico da série de preços
da_tsibble |>
  autoplot(price_adjusted, colour = "black") +
  facet_wrap(~ticker, scales = "free_y", ncol = 1)+
  scale_x_date(date_breaks = "4 months", label=quarter_label) +
  labs ( title = "Série de Preço", y = "Preço", x = "Data") +
 
  theme(
    plot.title = element_text(hjust = .5),
    axis.text.x = element_text(hjust = 1, angle = 45)
  )
 
```  

## 1.2. Log Retornos

```{r}
#| fig-width: 7
#| fig-height: 10
#| 
#criando gráfico da série de retornos
da_tsibble |>
  autoplot(ret_adjusted_prices, colour = "black") +
  facet_wrap(~ticker, scales = "free_y", ncol = 1) +
  scale_x_date(date_breaks = "4 months", labels = quarter_label) +
  labs ( title = "Série de Log Retornos", y = "Log Retornos", x = "Data") +
  theme(plot.title = element_text(hjust = 0.5),
    axis.text.x = element_text(hjust = 1, angle = 45)
  )

```

## 1.3 Avaliando heterocedasticidade condicional

Criação do log retorno ao quadrado (proxi da volatilidade)

```{r}
#| fig-width: 7
#| fig-height: 10

da_tsibble |>
  dplyr::mutate(ret2 = ret_closing_prices^2) |>
  autoplot(ret2, colour = "black") +
  facet_wrap(~ticker, ncol = 1)

```

**Verificando a existência de heterodasticidade condicional através dos seguintes métodos:**

* 1.2.1. ACF dos retornos quadráticos

* 1.2.2. Teste Ljung-Box dos retornos quadráticos

* 1.2.3. Teste Langrange Multiplier

### 1.2.1. ACF dos retornos ao quadrado

```{r}
# Gerando variável dos retornos quadráticos
da_tsibble  <-  da_tsibble |>
  dplyr::mutate(ret2 = ret_closing_prices^2)
```

```{r}
#| fig-width: 7
#| fig-height: 10
#| 
#ACF dos retornos ao quadrado
da_tsibble |>
  ACF(ret2) |>
  autoplot()
```

## Conclusões Gerais

::: {.callout-note}
### Dependência de Curto Prazo
Ações como AMZO34.SA e TASA4.SA mostram autocorrelação significativa de curto prazo que diminui rapidamente, indicando uma dependência temporal de curta duração nos retornos.

### Dependência Persistente
Ações como PRIO3.SA e RENT3.SA exibem autocorrelação mais persistente, sugerindo uma dependência temporal mais forte que pode se estender por períodos mais longos.

### Dependência Mínima
NVDC34.SA mostra autocorrelação mínima, sugerindo que seus retornos se comportam quase como ruído branco, com pouca ou nenhuma dependência temporal.
:::

### 1.2.2. Teste Ljung-Box
```{r}

resultados <- data.frame(Empresa = character(), "P-Valor" = numeric())

for (empresa in ativos) {
  # Filtrar o dataframe para a empresa atual
  da_tsibble_filtered <- da_tsibble |> filter(ticker == empresa)
  
  # Realizar o teste Box-Ljung
  box_test_result <- Box.test(da_tsibble_filtered$ret2, type = "Ljung-Box")
  
  # Adicionar o resultado ao dataframe de resultados
  resultados <- rbind(resultados, 
                               data.frame(Empresa = empresa, 
                                          "P-Valor" = box_test_result$p.value 
                                          ))
}

print(resultados)
```

* Não rejeita a hipótese nula: NVDC34.SA

* Rejeitam a hipótese nula: BCSA34.SA, RENT3.SA, PRIO3.SA e TASA4.SA, AMZO34.SA

### 1.2.3. Teste Lagrange Multiplier
```{r}


resultados_ml <- data.frame(Empresa = character(), "P-Valor" = numeric())

for (empresa in ativos) {
  # Filtrar o dataframe para a empresa atual
  da_tsibble_filtered <- da_tsibble |> filter(ticker == empresa)

  teste_ml <- ArchTest(da_tsibble_filtered$ret_closing_prices)

  # Adicionar o resultado ao dataframe de resultados
  resultados_ml <- rbind(resultados_ml, 
                               data.frame(Empresa = empresa, 
                                          "P-Valor" = teste_ml$p.value 
                                          ))
}

print(resultados_ml)
```

* Não rejeita a hipótese nula: NVDC34.SA

* Rejeitam a hipótese nula: BCSA34.SA, AMZO34.SA, RENT3.SA, PRIO3.SA, e TASA4.SA

# 2. Ajustando modelos Arch / Garch

## 2.1. Ajuste

```{r}
# Lista para comparação de modelos
modelos_garch <- list()
ics_modelos_garch  <- list()
resultados_tidy <- list()

distribuicao_erro  <- c("norm", "std")

for (empresa in unique(da_tsibble$ticker)) {
  retornos <- da_tsibble %>%
  subset(ticker== empresa) %>%
  select(ref_date,ret_closing_prices)
ret <- xts(retornos[,-1],order.by = ymd(retornos$ref_date))[-1,]
ret2 = ret**2
  # Loop pelos parâmetros de tipo de distribuição e m e n
  for (distribuicao in distribuicao_erro) {
    for (m in 1:3) {
      for (n in 0:3) {
      
        # Definir a fórmula do modelo com os parâmetros m e n atuais
        formula_garch <- paste0("~garch(", m, ",", n, ")")
        # Ajustar o modelo GARCH
        modelo_atual <- garchFit(formula = as.formula(formula_garch), data = ret, trace = FALSE, 
                                 include.mean = TRUE, cond.dist = distribuicao)
        # Armazenar o modelo ajustado na lista para visualização detalhada
        modelos_garch[[paste0("garch_", m, "_", n, "_", distribuicao, "_", empresa)]] <- modelo_atual
        # Armazenar o modelo ajustado na lista para comparação dos critérios de informação
        ics_modelos_garch[[paste0("garch_", m, "_", n, "_", distribuicao, "_", empresa)]] <- modelo_atual@fit$ics
    }
  }
}
  # Formatando resultados para melhor visualização 
  for (nome_modelo in names(ics_modelos_garch)) {
    valores <- ics_modelos_garch[[nome_modelo]]
    df <- data.frame(
      AIC = valores["AIC"],
      BIC = valores["BIC"]
    )
      resultados_tidy[[nome_modelo]] <- df
  }
} 

resultados_tidy_df <- do.call(rbind, resultados_tidy)%>% 
  rownames_to_column()  %>% 
    separate(rowname, c("Modelo", "m", "n", "dist", "ticker"),
    sep = "_")  %>% 
    arrange(AIC)  %>% 
    distinct(ticker, .keep_all = TRUE)

```

## 2.2. Análise dos resíduos
```{r}
residuos <- list()

for (i in 1:nrow(resultados_tidy_df)) {
  # Concatenando o nome do modelo para ficar como consta no objeto modelos_garch
  model_name <- paste0(resultados_tidy_df$Modelo[i], "_", resultados_tidy_df$m[i], "_", resultados_tidy_df$n[i], "_", resultados_tidy_df$dist[i], "_", resultados_tidy_df$ticker[i])
  
  # Checando se o modelo está entre os melhores
  if (model_name %in% names(modelos_garch)) {
    # Acessando os melhores modelos e calculando resíduos
    current_model <- modelos_garch[[model_name]]
    residuos[[model_name]] <- residuals(current_model, standardize = TRUE)
  }
}
str(residuos)

```

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!INSERIR CONCLUSÃO AQUI!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

# 3. Previsão dos Ativos (HELIO)

```{r}
# forecast <- predict(modelos_garch$garch_1_1_std, n.ahead = 1)
# forecast
```

```{r}
# # Criação inicial do data frame vazio
# comparacao_forecast <- data.frame(Empresa = character(), meanForecast = double(), meanError = double(), standardDeviation = double())

# # Adicionando os resultados da previsão para a "Amazon" ao data frame
# comparacao_forecast <- rbind(comparacao_forecast, 
#                              data.frame(Empresa = "Santander",
#                                         meanForecast = forecast$meanForecast,
#                                         meanError = forecast$meanError,
#                                         standardDeviation = forecast$standardDeviation))
```

# 4. Portfólio

## 4.1. Retorno, Risco e Ratio

```{r}

pesos  <- c(0.10, 0.20, 0.20, 0.10, 0.20, 0.20) %>% 
  setNames(ativos)

portfolio  <- da_tsibble  %>% 
                select(ticker, ret_closing_prices)

retornos_portfolio <- portfolio |>
  ungroup() %>% 
  as_tibble() %>% 
  tidyquant::tq_portfolio(
    ticker,
    ret_closing_prices,
    weights = pesos,
    col_rename = "Retornos"
  )

paste0("Média dos retornos do portfólio: ", round(mean(retornos_portfolio$Retornos),7))

```

## 4.2. Modelagem Garch
```{r}
modelos_garch_portfolio <- list()
ics_modelos_garch_portfolio  <- list()
resultados_tidy_portfolio <- list()


for (distribuicao in distribuicao_erro) {
  for (m in 1:3) {
    for (n in 0:3) {
    
      # Definir a fórmula do modelo com os parâmetros m e n atuais
      formula_garch <- paste0("~garch(", m, ",", n, ")")

      # Ajustar o modelo GARCH
      modelo_atual <- garchFit(
        formula = as.formula(formula_garch),
        data = retornos_portfolio$Retornos,
        trace = FALSE,          
        include.mean = TRUE, 
        cond.dist = distribuicao)

      # Armazenar o modelo ajustado na lista para visualização detalhada
      modelos_garch_portfolio[[paste0("garch_", m, "_", n, "_", distribuicao)]] <- modelo_atual
      
      # Armazenar o modelo ajustado na lista para comparação dos critérios de informação
      ics_modelos_garch_portfolio[[paste0("garch_", m, "_", n, "_", distribuicao)]] <- modelo_atual@fit$ics
    }
  }
}
# Formatando resultados para melhor visualização 
  for (nome_modelo in names(ics_modelos_garch_portfolio)) {
    valores <- ics_modelos_garch_portfolio[[nome_modelo]]
    df <- data.frame(
      AIC = valores["AIC"],
      BIC = valores["BIC"]
    )
      resultados_tidy_portfolio[[nome_modelo]] <- df
}

resultados_tidy_df_portfolio <- do.call(rbind, resultados_tidy_portfolio)%>% 
  rownames_to_column()  %>% 
    # separate(rowname, c("Modelo", "m", "n", "dist"),
    # sep = "_")  %>% 
    arrange(AIC)  %>% 
    slice(1)

resultados_tidy_df_portfolio
```

## 4.3. Forecast do Portfólio

```{r}
forecast <- predict(modelos_garch_portfolio$garch_1_1_std, n.ahead = 1)
forecast
```


# Otimizar o retorno portfólio 