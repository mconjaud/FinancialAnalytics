---
title: "Financial Analytics - Trabalho Final"
authors:
  - name: Michel Maurice Conjaud
  - name: Hélio Pereira Oliveira
  - name: Renan Cabral
  - name: Tiago Evangelista Pardo
format:
  html:
    code-fold: true
    embed-resources: true
    smooth-scroll: true
    theme: cerulean
    toc: true
    toc-expand: true
    toc-title: "Sumário"
    toc_float: true

execute:
  freeze: true
  warning: false
  cache: true
---

# 0. Bibliotecas e Importação de Dados

Bibliotecas
```{r}
#| output: false
library(ggplot2)
library(fpp3)
library(rugarch)
library(tsibble)
library(yfR)
library(zoo)
library(xts)
library(lubridate)
library(patchwork)
library(lmtest)
library(fGarch)
library(xts)
```

Seleção das Ações/Ativos e definição da data de início: 01/01/2019
```{r}

start_date <- '2019-01-01'

ativos <- c(
  "NVDC34.SA",
  "BCSA34.SA", 
  "AMZO34.SA",
  "RENT3.SA",
  "PRIO3.SA",
  "TASA4.SA"
)
```

Selecionando as ações

```{r}
da <- yfR::yf_get(
  ativos,
  first_date = start_date,
  last_date = Sys.Date(),
  bench_ticker = "^BVSP",
  type_return = "log",
  freq_data = "daily",
  do_complete_data = TRUE
)
view(da)

```

Data mínima comum a todas as séries

```{r}
# Capturando menor data da base 
data_corte <- da |>
  dplyr::group_by(ticker) |>
  dplyr::filter(ref_date == min(ref_date)) |>
  dplyr::ungroup() |>
  with(max(ref_date))

data_corte
```

```{r}
# Df com data mínima
da_train <- da |>
  dplyr::filter(ref_date > data_corte) 

view(da_train)  
```


Transformando dataframe em tsbible 

```{r}
#| output: false

da_tsibble <- da_train |>
  as_tsibble(key = ticker, index = ref_date, regular = FALSE)

View(da_tsibble)

```


# 1. Gráficos de Preço, Retorno e Avaliação de Heterodasticidade Condicional

## 1.1. Gráfico de preços e dos log retornos

### 1.1.1. Preços

```{r}
#Função para formatar legenda
quarter_label <- function(x) {
  paste0(year(x), "Q", quarter(x))
}
```


```{r}
#criando gráfico da série de preços
da_tsibble |>
  autoplot(price_adjusted, colour = "black") +
  facet_wrap(~ticker, scales = "free_y", ncol = 1)+
  scale_x_date(date_breaks = "4 months", label=quarter_label) +
  labs ( title = "Série de Preço", y = "Preço", x = "Data") +
  theme(plot.title = element_text(hjust = 0.1))
```  


### 1.1.2. Log Retornos

```{r}
#criando gráfico da série de retornos
da_tsibble |>
  autoplot(ret_adjusted_prices, colour = "black") +
  facet_wrap(~ticker, scales = "free_y", ncol = 1) +
  scale_x_date(date_breaks = "4 months", labels = quarter_label) +
  labs ( title = "Série de Log Retornos", y = "Log Retornos", x = "Data") +
  theme(plot.title = element_text(hjust = 0.5))

```

## 1.2 Analisando possível heterocedasticidade condicional

Criação do log retorno ao quadrado (proxi da volatilidade)
```{r}
da_tsibble |>
  dplyr::mutate(ret2 = ret_closing_prices^2) |>
  autoplot(ret2, colour = "black") +
  facet_wrap(~ticker, ncol = 1)

```

### 1.2.1. ACF dos retornos ao quadrado

```{r}
# Gerando variável dos retornos quadráticos
da_tsibble  <-  da_tsibble |>
  dplyr::mutate(ret2 = ret_closing_prices^2)
```

```{r}
#ACF dos retornos ao quadrado
da_tsibble |>
  ACF(ret2) |>
  autoplot()
```

**Interpretação**
* AMZO3, BCSA3, PRIO3 e RENT3 mostram autocorrelações significativas nos primeiros lags, indicando que a volatilidade desses retornos pode ser dependente no tempo. 

* NVCD, por outro lado, não apresenta uma dependência temporal forte, sugerindo ausência de heterocedasticidade significativa. 

* TASA4 tem algumas autocorrelações significativas, mas menos pronunciadas em comparação com as outras séries.


### 1.2.2. Teste Ljung-Box
```{r}

resultados <- data.frame(Empresa = character(), "P-Valor" = numeric())

for (empresa in ativos) {
  # Filtrar o dataframe para a empresa atual
  da_tsibble_filtered <- da_tsibble |> filter(ticker == empresa)
  
  # Realizar o teste Box-Ljung
  box_test_result <- Box.test(da_tsibble_filtered$ret2, type = "Ljung-Box")
  
  # Adicionar o resultado ao dataframe de resultados
  resultados <- rbind(resultados, 
                               data.frame(Empresa = empresa, 
                                          "P-Valor" = box_test_result$p.value 
                                          ))
}

print(resultados)
```

**Interpretação**
* Não rejeita a hipótese nula: NVDC34.SA
* Rejeitam a hipótese nula: BCSA34.SA, RENT3.SA, PRIO3.SA e TASA4.SA, AMZO34.SA

### 1.2.3. Teste Lagrange Multiplier
```{r}
library(FinTS)

resultados_ml <- data.frame(Empresa = character(), "P-Valor" = numeric())

for (empresa in ativos) {
  # Filtrar o dataframe para a empresa atual
  da_tsibble_filtered <- da_tsibble |> filter(ticker == empresa)

  teste_ml <- ArchTest(da_tsibble_filtered$ret_closing_prices)

  # Adicionar o resultado ao dataframe de resultados
  resultados_ml <- rbind(resultados_ml, 
                               data.frame(Empresa = empresa, 
                                          "P-Valor" = teste_ml$p.value 
                                          ))
}

print(resultados_ml)
```

**Interpretação**
* Não rejeita a hipótese nula: NVDC34.SA
* Rejeitam a hipótese nula: BCSA34.SA, AMZO34.SA, RENT3.SA, PRIO3.SA, e TASA4.SA

# 2. Ajustando modelos Arch / Garch

## 2.1 Fit e Escolha do melhor modelo para cada ação (Menor AIC)

```{r} 
# Lista para comparação de modelos
modelos_garch <- list()
ics_modelos_garch  <- list()
resultados_tidy <- list()

distribuicao_erro  <- c("norm", "std")

  for (empresa in unique(da_tsibble$ticker)) {
    retornos <- da_tsibble %>%
    subset(ticker== empresa) %>%
    select(ref_date,ret_closing_prices)
  ret <- xts(retornos[,-1],order.by = ymd(retornos$ref_date))[-1,]
  ret2 = ret**2
  plot(ret2)

    # Loop pelos parâmetros de tipo de distribuição e m e n
    for (distribuicao in distribuicao_erro) {
      for (m in 1:3) {
        for (n in 0:3) {
        
          # Definir a fórmula do modelo com os parâmetros m e n atuais
          formula_garch <- paste0("~garch(", m, ",", n, ")")

          # Ajustar o modelo GARCH
          modelo_atual <- garchFit(formula = as.formula(formula_garch), data = ret, trace = FALSE, 
                                   include.mean = TRUE, cond.dist = distribuicao)

          # Armazenar o modelo ajustado na lista para visualização detalhada
          modelos_garch[[paste0("garch_", m, "_", n, "_", distribuicao, "_", empresa)]] <- modelo_atual
          # Armazenar o modelo ajustado na lista para comparação dos critérios de informação
          ics_modelos_garch[[paste0("garch_", m, "_", n, "_", distribuicao, "_", empresa)]] <- modelo_atual@fit$ics
        }
      }
    }

    # Formatando resultados para melhor visualização 
    for (nome_modelo in names(ics_modelos_garch)) {
      valores <- ics_modelos_garch[[nome_modelo]]
      df <- data.frame(
        AIC = valores["AIC"],
        BIC = valores["BIC"]
      )
        resultados_tidy[[nome_modelo]] <- df
    }
    } 
    resultados_tidy_df <- do.call(rbind, resultados_tidy)

resultados_tidy_df2 <- resultados_tidy_df  %>% rownames_to_column()  %>% 
                          separate(rowname, c("Modelo", "m", "n", "dist", "ticker"),
                          sep = "_")  %>% 
                          arrange(AIC)  %>% 
                          distinct(ticker, .keep_all = TRUE)

print(resultados_tidy_df2)          

```

### 2.1.2. Avaliação do melhor modelo de cada ação

Análise detalhada do melhor modelo de cada ação pelos critérios de informação
```{r}
Resumo_AMAZO34 <- summary(modelos_garch$garch_1_2_std_AMZO34.SA)
Resumo_BCSA34 <- summary(modelos_garch$garch_1_1_std_BCSA34.SA)
Resumo_RENT3 <- summary(modelos_garch$garch_2_1_std_RENT3.SA)
Resumo_TASA4 <- summary(modelos_garch$garch_1_1_std_TASA4.SA)
Resumo_NVDC34 <- summary(modelos_garch$garch_1_1_std_NVDC34.SA)
Resumo_PRIO3 <- summary(modelos_garch$garch_1_1_std_PRIO3.SA)

print(Resumo_AMAZO34)
print(Resumo_BCSA34)
print(Resumo_RENT3)
print(Resumo_TASA4)
print(Resumo_NVDC34)
print(Resumo_PRIO3)

# ARRUMAR CÓDIGO 

```

**Interpretação**

* Baseado nos coeficientes e nos critérios de informação:

* AMAZO34 tem os valores mais baixos de AIC (-4.853336), BIC (-4.826964), SIC (-4.853390) e HQIC (-4.843380), indicando que é o melhor modelo entre as ações analisadas.
* BCSA34 tem os próximos melhores valores dos critérios.
* RENT3, TASA4, NVDC34 e PRIO3 seguem, com valores crescentes dos critérios, indicando um ajuste inferior comparado a AMAZO34 e BCSA34.

* Conclusão: Com base nos Critérios de Informação, o modelo para AMAZO34 é o que apresenta o melhor ajuste entre os modelos apresentados, seguido pelo modelo para BCSA34. 

### 2.1.3. Análise dos retornos e volatilidade 

Gráfico dos retornos de cada ação
```{r}

retornos <- da_tsibble %>%
    select(ref_date,ret_closing_prices)
  ret <- xts(retornos[,-1],order.by = ymd(retornos$ref_date))[-1,]

da_tsibble |>
  dplyr::mutate(ret = ret_closing_prices) |>
  autoplot(ret, colour = "black") +
  facet_wrap(~ticker, ncol = 1)
```

**Interpretação**

* AMAZO34 e PRIO3 destacam-se pela alta volatilidade, indicando uma maior sensibilidade a eventos de mercado. 
* NVDC34 também mostra volatilidade significativa, refletindo a natureza dinâmica do setor de tecnologia. 
* Em contraste, BCSA34 e TASA4 são mais estáveis, indicando menor exposição a variações extremas. 
* RENT3, inicialmente volátil, parece se estabilizar com o tempo, sugerindo uma adaptação do mercado às suas operações

Gráfico da volatilidade de cada ação
```{r}

model_names <- c(
  "garch_1_2_std_AMZO34.SA",
  "garch_1_1_std_BCSA34.SA",
  "garch_1_1_std_PRIO3.SA",
  "garch_1_1_std_NVDC34.SA",
  "garch_1_1_std_TASA4.SA",
  "garch_1_1_std_BCSA34.SA"
)
titles <- c(
  "Volatilidade AMZO34.SA",
  "Volatilidade BCSA34.SA",
  "Volatilidade PRIO3.SA",
  "Volatilidade NVDC34.SA",
  "Volatilidade TASA4.SA",
  "Volatilidade BCSA34.SA"
)

par(mfrow = c(6, 1)) 

sigma  <-  list()
for (i in 1:length(model_names)) {
  model_name <- model_names[i]
  title <- titles[i]
  
  model <- modelos_garch[[model_name]]
  sigma <- cbind(model@sigma.t) 
  
  print(plot(model@sigma.t, main = title))
  }
```

**Interpretação**

* AMAZO34 e PRIO3 mostram uma alta volatilidade inicial, com uma diminuição ao longo do tempo, mas com surtos periódicos significativos.
* BCSA34 e TASA4 têm uma volatilidade que diminui rapidamente e se estabiliza, com menos picos extremos.
* NVDC34 apresenta uma alta volatilidade com flutuações frequentes, refletindo a natureza dinâmica do setor de tecnologia.
* RENT3 tem alta volatilidade inicial que diminui com o tempo, mas com surtos ocasionais, indicando períodos de instabilidade e reações a eventos de mercado.

## 2.1.4. Análise dos resíduos

```{r}

residuos <- list()
par(mfrow = c(6, 1))

# Iterando sobre cada linha do data frame `resultados_tidy_df2`
for (i in 1:nrow(resultados_tidy_df2)) {
  
  # Concatenando o nome do modelo 
  model_name <- paste0(resultados_tidy_df2$Modelo[i], "_", 
                       resultados_tidy_df2$m[i], "_", 
                       resultados_tidy_df2$n[i], "_", 
                       resultados_tidy_df2$dist[i], "_", 
                       resultados_tidy_df2$ticker[i])
  
  # Checando se o modelo está entre os melhores
  if (model_name %in% names(modelos_garch)) {
    # Acessando os melhores modelos e calculando os resíduos
    current_model <- modelos_garch[[model_name]]
    residuos[[model_name]] <- residuals(current_model, standardize=TRUE)
    
    # Plotando os resíduos
    ts.plot(residuos[[model_name]], main = model_name)
  }
}
```

**Interpretação**
* Padrões: Não foi encontrado padrões claros, o que é um bom sinal. Isso sugere que os modelos estão capturando bem a estrutura dos dados.
* Outliers: Todos os gráficos têm alguns outliers, o que faz sentido em séries financeiras. 
* Heterocedasticidade: três ações mostram variações na amplitude dos resíduos, sugerindo que pode haver alguma heterocedasticidade residual (RENT3.SA & NVDC334.SA & BCSA34.SA). 

## 3.0 Prever volatilidade um passo à frente

Função que ajusta o modelo e faz as previsões
```{r}

# Dados de exemplo (volatilidade_passo_frente)
volatilidade_passo_frente <- data.frame(
  Modelo = c("garch", "garch", "garch", "garch", "garch", "garch"),
  m = c(1, 1, 2, 1, 1, 1),
  n = c(2, 1, 1, 1, 1, 1),
  dist = c("std", "std", "std", "std", "std", "std"),
  ticker = c("AMZO34.SA", "BCSA34.SA", "RENT3.SA", "TASA4.SA", "NVDC34.SA", "PRIO3.SA"),
  AIC = c(-4.853336, -4.751056, -4.609009, -4.227347, -4.109136, -4.106262),
  BIC = c(-4.826964, -4.729079, -4.582637, -4.205371, -4.087160, -4.084286)
)

# Função para prever a volatilidade um passo à frente
prever_volatilidade <- function(ticker, m, n, dist) {
  # Simulação de dados de retorno (substitua com seus próprios dados)
  set.seed(123)
  returns <- rnorm(1000)

  # Configuração do modelo GARCH
  spec <- ugarchspec(
    variance.model = list(model = "sGARCH", garchOrder = c(m, n)),
    mean.model = list(armaOrder = c(0, 0)),
    distribution.model = dist
  )
  
  # Ajustar o modelo GARCH
  fit <- ugarchfit(spec = spec, data = returns)
  
  # Prever a volatilidade um passo à frente
  forecast <- ugarchforecast(fit, n.ahead = 1)
  sigma_forecast <- sigma(forecast)
  
  return(sigma_forecast)
}

# Loop para prever a volatilidade para cada modelo na lista
volatilidade_passo_frente$volatilidade_forecast <- NA

for (i in 1:nrow(volatilidade_passo_frente)) {
  ticker <- volatilidade_passo_frente$ticker[i]
  m <- volatilidade_passo_frente$m[i]
  n <- volatilidade_passo_frente$n[i]
  dist <- volatilidade_passo_frente$dist[i]
  
  volatilidade <- prever_volatilidade(ticker, m, n, dist)
  volatilidade_passo_frente$volatilidade_forecast[i] <- volatilidade
}

# Mostrar os resultados
print(volatilidade_passo_frente)

```

## 4.0 Comparar volatilidades entre os retornos selecionados (quais são maiores e menores, relacionando com algum storytelling);

* Maior Volatilidade: Amazon possui a maior volatilidade, refletindo seu alto nível de exposição ao mercado global e inovações tecnológicas.

* Menor Volatilidade: Banco Santander, Taurus, Nvidia, e Prio apresentam menor volatilidade, sugerindo operações estáveis e previsíveis em seus respectivos setores.

* Volatilidade Intermediária: Localiza tem uma volatilidade moderada, compatível com o setor de mobilidade que combina demanda estável com variações econômicas.

* Obs: NVIDIA está surfando o boom de IA, alcançando os USDD3Tri de valor de mercado, tendência de continuar subida de preço. 
Obs: Santander, bancos tendem a ser mais estáveis no mercado brasileiro. 

